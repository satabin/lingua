alphabet

// l'alphabet recouvre l'ensemble des lettres qui peuvent composer un mot en français,
// par ordre alphabétique pour cette langue
// les diacritiques apparaissent dans l'ordre : aigu, grave, circonflexe puis tréma
a à â æ b c ç d e é è ê ë f g h i î ï j k l m n o ô œ p q r s t u ù û ü v w x y ÿ z ;

separators

- ’ ;

categories

nom as N;
verbe as V;
préposition as P;
adjectif as Adj;
adverbe as Adv;
déterminant as Det;
conjonction as Conj;
complémenteur as C;
négation as Neg;

tags

clitique as Cl;
commun as Comm;
interrogratif as Qu;

// pour les noms composés, les traits indiquent comment ils sont faits
// le trait NC (et ses enfants) sont marqués comme `private`, ce qui signifie
// qu’il ne sont utilisés que pour construire le Fst mais ne seront pas exportés
// dans le résultat
private nom-composé as NC {
  verbe-nom as VN;
  verbe-nom-indénombrable as VNI;
  nom-nom as NN;
  nom-nom-indénombrable as NNI;
  nom-adjectif as NAdj;
  adjectif-nom as AdjN;
  adverbe-nom as AdvN;
}

// deux auxiliaires existent, être et avoir
auxiliaire as Aux {
  être as E;
  avoir as A;
}

// les marqueurs de nombre
nombre as Nb {
  singulier as Sg;
  pluriel as Pl;
}

// les genres
genre as G {
  masculin as Masc;
  féminin as Fém;
}

// modes
mode as M {
  indicatif as Ind;
  impératif as Imper;
  subjonctif as Subj;
  conditionnel as Cond;
}

// temps
temps as Tps {
  présent as Prés;
  passé-simple as PassSimp;
  passé-composé as PacsComp;
  futur as Fut;
  imparfait as Imp;
  plus-que-parfait as Pqp;
}

// rôles thématiques
role as R {
  agent as Ag;
  thème as Th;
  patient as Pat;
  psy-chose as Psy;
  instrument as Inst;
  locatif as Loc;
  but as But;
  source as Src;
}

premier-groupe as G1;
deuxième-groupe as G2;
troisième-groupe as G3;

première-personne as 1ère;
deuxième-personne as 2ème;
troisième-personne as 3ème;

private exception as Exn;

lexikon Nom @N {

  arbre / +Masc ;

  chasse-neige / +Masc +VNI ;
  tire-bouchon / +Masc +VN ;
  chou-fleur / +Masc +NN ;
  timbre-poste / +Masc +NNI ;
  grand-mère / +Fém +AdjN ;
  coffre-fort / +Masc +NAdj ;
  micro-onde / +Masc +AdjN ;
  arrière-boutique / +Fém +AdvN ;
  pince-sans-rire / +Fém ;
  pince-sans-rire / +Masc ;

  // pour les noms composés d'un verbe et d'un nom, seul le nom prend la marque
  // du pluriel s'il est dénombrable, sinon le nom reste invariable
  rewrite pluriel +Pl {
    rule ..al / -NC => ..aux
       | ..eau / -NC => ..eaux
       | .. / -NC => ..s
       // après la flèche, le `..` indique la première ascription `..` avant la flèche
       // après la flèche, le `..` indique la deuxième ascription `..` avant la flèche
       | ..-.. / +VNI => ..-..
       // la notation @(...) indique que la règle de réécriture courante est appliquée au résulat
       // du remplacement entre parenthèses de manière récursive. Le résultat a la même catégorie
       // et aucune étiquette
       | ..-.. / +VN  => ..-@(..)

       | ..-.. / +NNI => @(..)-..
       | ..-.. / +NN => @(..)-@(..)

       // utiliser `..` après la flèche fait référence aux captures du pattern de manière implicite
       // le premier `..` est équivalent à `..`, le deuxième à `..` et ainsi de suite
       // Cette notation est plutôt indiquée lorsque qu’il n’y a qu’un seul groupe capturé afin
       // d’éviter les ambiguïtés
       | ..o-.. / +AdjN => ..o-@(..)
       | ..-.. / +AdjN => @(..)-@(..)
       | ..-.. / +NAdj => @(..)-@(..)

       | ..-.. / +AdvN => ..-@(..) ;
  }

}

lexikon Nom-Exceptions @N {

  festival / +Masc +Exn ;
  // le `s` suivi de `:_` permet de spécifier la racinisation de `festivals` en `festival`
  festival s:_ / +Masc +Pl +Exn ;

}

// `@V` signifie que la catégorie `V` est affectée au mot en entrée de ce lexique
lexikon VG1 @V +G1 {

  manger ;
  tracer ;
  danser ;

  rewrite présent-indicatif +Prés +Ind {
    // ce cas signifie que le suffixe `r` (noté `..r`, un préfixe est noté `r..`)
    // est remplacé par une transition vide
    // qui ajoute les traits +Sg et +1ère
    // ainsi `mange` est annoté comme suit:
    // `manger{V +G1 +Prés +Ind +Sg +1ère}`
    // cette règle est équivalente à la suite de transitions suivante :
    // `mange _:r @V +G1 +Prés +Ind +Sg +1ère`
    rule ..r => .. / +Sg +1ère ;
    rule ..r => ..s / +Sg +2ème ;
    // avec cette règle nous voyons que `mange` est annoté comme
    // {V +G1 +Prés +Ind +Sg +1ère} et comme
    // {V +G1 +Prés +Ind +Sg +3ème}
    rule ..r => .. / +Sg +3ème ;
    // ici nous écrivons un patron plus complexe avec des sous-cas
    // les sous-cas sont appliqués en séquence, et le premier qui correspond
    // est choisi. Si aucun ne correspond la règle ne s'applique pas ici.
    // contrairement aux `rule`s dont l'ordre n'a pas d'importance, il faut veiller
    // ici à correctement ordonner les cas afin que les plus spécifiques arrivent avant
    // les plus généraux
    rule ..ger => ..geons / +Pl +1ère
       | ..cer => ..çons / +Pl +1ère
       | ..er => ..ons / +Pl +1ère ;
    rule ..r => ..z / +Pl +2ème ;
    rule ..r => ..nt / +Pl +3ème ;
  }

  rewrite futur-indicatif +Fut +Ind {
    rule .. => ..ai / +Fut +Ind +Sg +1ère ;
    rule .. => ..as / +Fut +Ind +Sg +2ème ;
    rule .. => ..a / +Fut +Ind +Sg +3ème ;
    rule .. => ..ons / +Fut +Ind +Pl +1ère ;
    rule .. => ..ez / +Fut +Ind +Pl +2ème ;
    rule .. => ..ont / +Fut +Ind +Pl +3ème ;
  }

  rewrite passé-simple-indicatif +PassSimp +Ind {
    rule ..ger => ..geai / +Sg +1ère
       | ..cer => ..çai / +Sg +1ère
       | ..er => ..ai / +Sg +1ère ;
    rule ..ger => ..geas / +Sg +2ème
       | ..cer => ..ças / +Sg +2ème
       | ..er => ..as / +Sg +2ème ;
    rule ..ger => ..gea / +Sg +3ème
       | ..cer => ..ça / +Sg +3ème
       | ..er => ..a / +Sg +3ème ;
    rule ..ger => ..geâmes / +Pl +1ère
       | ..cer => ..çâmes / +Pl +1ère
       | ..er => ..âmes / +Pl +1ère ;
    rule ..ger => ..geâtes / +Pl +2ème
       | ..cer => ..çâtes / +Pl +2ème
       | ..er => ..âtes / +Pl +2ème ;
    rule ..er => ..èrent / +Pl +3ème ;
  }

  rewrite imparfait-indicatif +Imp +Ind {
    rule ..ger => ..geais / +Sg +1ère
       | ..cer => ..çais / +Sg +1ère
       | ..er => ..ais / +Sg +1ère ;
    rule ..ger => ..geais / +Sg +2ème
       | ..cer => ..çais / +Sg +2ème
       | ..er => ..ais / +Sg +2ème ;
    rule ..ger => ..geait / +Sg +3ème
       | ..cer => ..çait / +Sg +3ème
       | ..er => ..ait / +Sg +3ème ;
    rule ..er => ..ions / +Pl +1ère ;
    rule ..er => ..iez / +Pl +2ème ;
    rule ..ger => ..geaient / +Pl +3ème
       | ..cer => ..çaient / +Pl +3ème
       | ..er => ..aient / +Pl +3ème ;
  }

}
